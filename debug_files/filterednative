[Null
,Null
,Null
,Para [Str "Enum",Str " ",Str "Option"]
,Null
,Null
,Null
,Div ("",[],[])
 [Header 1 ("",[],[]) [Span ("",["in-band"],[]) [Str "Enum",Str " ",Span ("",[],[]) [Str "std"],Str "::",Span ("",[],[]) [Str "option"],Str "::",Span ("",[],[]) [Str "Option"]]]
 ,Div ("",["docblock","type-decl","hidden-by-usual-hider"],[])
  [Para [Str "#+BEGIN_SRC rust \n",Str "pub enum Option<T> {\n    None,\n    Some(T),\n}",Str "\n#+END_SRC"]]
 ,Div ("",[],[])
  [Para [Str "The",Str " ",Code ("",[],[]) "Option",Str " ",Str "type.",Str " ",Str "See",Str " ",Span ("",[],[]) [Str "the",Str " ",Str "module",Str " ",Str "level",Str " ",Str "documentation"],Str " ",Str "for",Str " ",Str "more."]]
 ,Header 1 ("",[],[]) [Str "Variants"]
 ,Div ("",[],[])
  [Div ("",[],[])
   [Header 3 ("",[],[]) [Code ("None.v",[],[]) "None"]
   ,Plain []]]
 ,Div ("",[],[])
  [Para [Str "No",Str " ",Str "value"]]
 ,Div ("",[],[])
  [Div ("",[],[])
   [Header 3 ("",[],[]) [Code ("Some.v",[],[]) "Some(T)"]
   ,Plain []]]
 ,Div ("",[],[])
  [Para [Str "Some",Str " ",Str "value",Str " ",Code ("",[],[]) "T"]]
 ,Header 1 ("",[],[]) [Str "Implementations"]
 ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Option<T>"]
 ,Div ("",["impl-items"],[])
  [Header 3 ("",[],[]) [Code ("",[],[]) "pub fn is_some(&self) -> bool",Str " ",Note [Plain [Str "   \"if you intended to assert that this has a value, consider `.unwrap()` instead\""]]]
  ,Div ("",[],[])
   [Para [Str "Returns",Str " ",Code ("",[],[]) "true",Str " ",Str "if",Str " ",Str "the",Str " ",Str "option",Str " ",Str "is",Str " ",Str "a",Str " ",Span ("",[],[]) [Code ("",[],[]) "Some"],Str " ",Str "value."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let x: Option<u32> = Some(2);\nassert_eq!(x.is_some(), true);\n\nlet x: Option<u32> = None;\nassert_eq!(x.is_some(), false);",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn is_none(&self) -> bool",Str " ",Note [Plain [Str "   \"if you intended to assert that this doesn't have a value, consider \\                   `.and_then(|| panic!(\\\"`Option` had a value when expected `None`\\\"))` instead\""]]]
  ,Div ("",[],[])
   [Para [Str "Returns",Str " ",Code ("",[],[]) "true",Str " ",Str "if",Str " ",Str "the",Str " ",Str "option",Str " ",Str "is",Str " ",Str "a",Str " ",Span ("",[],[]) [Code ("",[],[]) "None"],Str " ",Str "value."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let x: Option<u32> = Some(2);\nassert_eq!(x.is_none(), false);\n\nlet x: Option<u32> = None;\nassert_eq!(x.is_none(), true);",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("",[],[]) "pub fn contains<U>(&self, x: &U) -> bool where\160\160\160\160U: PartialEq<T>,\160",Str " "]
  ,Plain [Str "This",Str " ",Str "is",Str " ",Str "a",Str " ",Str "nightly-only",Str " ",Str "experimental",Str " ",Str "API.",Str " ",Str "(",Code ("",[],[]) "option_result_contains",Str "\160",Span ("",[],[]) [Str "#62358"],Str ")",Str " "]
  ,Div ("",[],[])
   [Para [Str "Returns",Str " ",Code ("",[],[]) "true",Str " ",Str "if",Str " ",Str "the",Str " ",Str "option",Str " ",Str "is",Str " ",Str "a",Str " ",Span ("",[],[]) [Code ("",[],[]) "Some"],Str " ",Str "value",Str " ",Str "containing",Str " ",Str "the",Str " ",Str "given",Str " ",Str "value."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "#![feature(option_result_contains)]\n\nlet x: Option<u32> = Some(2);\nassert_eq!(x.contains(&2), true);\n\nlet x: Option<u32> = Some(3);\nassert_eq!(x.contains(&2), false);\n\nlet x: Option<u32> = None;\nassert_eq!(x.contains(&2), false);",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("as_ref.v",[],[]) "pub fn as_ref(&self) -> Option<&T>"]
  ,Div ("",[],[])
   [Para [Str "Converts",Str " ",Str "from",Str " ",Code ("",[],[]) "&Option<T>",Str " ",Str "to",Str " ",Code ("",[],[]) "Option<&T>",Str "."]
   ,Null
   ,Para [Str "Converts",Str " ",Str "an",Str " ",Code ("",[],[]) "Option<",Span ("",[],[]) [Code ("",[],[]) "String"],Code ("",[],[]) ">",Str " ",Str "into",Str " ",Str "an",Str " ",Code ("",[],[]) "Option<",Span ("",[],[]) [Code ("",[],[]) "usize"],Code ("",[],[]) ">",Str ",",Str " ",Str "preserving",Str " ",Str "the",Str " ",Str "original.",Str " ",Str "The",Str " ",Span ("",[],[]) [Code ("",[],[]) "map"],Str " ",Str "method",Str " ",Str "takes",Str " ",Str "the",Str " ",Code ("",[],[]) "self",Str " ",Str "argument",Str " ",Str "by",Str " ",Str "value,",Str " ",Str "consuming",Str " ",Str "the",Str " ",Str "original,",Str " ",Str "so",Str " ",Str "this",Str " ",Str "technique",Str " ",Str "uses",Str " ",Code ("",[],[]) "as_ref",Str " ",Str "to",Str " ",Str "first",Str " ",Str "take",Str " ",Str "an",Str " ",Code ("",[],[]) "Option",Str " ",Str "to",Str " ",Str "a",Str " ",Str "reference",Str " ",Str "to",Str " ",Str "the",Str " ",Str "value",Str " ",Str "inside",Str " ",Str "the",Str " ",Str "original."]
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let text: Option<String> = Some(\"Hello, world!\".to_string());\n// First, cast `Option<String>` to `Option<&String>` with `as_ref`,\n// then consume *that* with `map`, leaving `text` on the stack.\nlet text_length: Option<usize> = text.as_ref().map(|s| s.len());\nprintln!(\"still can print text: {:?}\", text);",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("as_mut.v",[],[]) "pub fn as_mut(&mut self) -> Option<&mut T>"]
  ,Div ("",[],[])
   [Para [Str "Converts",Str " ",Str "from",Str " ",Code ("",[],[]) "&mut Option<T>",Str " ",Str "to",Str " ",Code ("",[],[]) "Option<&mut T>",Str "."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let mut x = Some(2);\nmatch x.as_mut() {\n    Some(v) => *v = 42,\n    None => {},\n}\nassert_eq!(x, Some(42));",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("as_pin_ref.v",[],[]) "pub fn as_pin_ref(self: Pin<&Option<T>>) -> Option<Pin<&T>>"]
  ,Div ("",[],[])
   [Para [Str "Converts",Str " ",Str "from",Str " ",Span ("",[],[]) [Code ("",[],[]) "Pin"],Code ("",[],[]) "<&Option<T>>",Str " ",Str "to",Str " ",Code ("",[],[]) "Option<",Span ("",[],[]) [Code ("",[],[]) "Pin"],Code ("",[],[]) "<&T>>",Str "."]]
  ,Header 3 ("",[],[]) [Code ("as_pin_mut.v",[],[]) "pub fn as_pin_mut(self: Pin<&mut Option<T>>) -> Option<Pin<&mut T>>"]
  ,Div ("",[],[])
   [Para [Str "Converts",Str " ",Str "from",Str " ",Span ("",[],[]) [Code ("",[],[]) "Pin"],Code ("",[],[]) "<&mut Option<T>>",Str " ",Str "to",Str " ",Code ("",[],[]) "Option<",Span ("",[],[]) [Code ("",[],[]) "Pin"],Code ("",[],[]) "<&mut T>>",Str "."]]
  ,Header 3 ("",[],[]) [Code ("expect.v",[],[]) "pub fn expect(self, msg: &str) -> T"]
  ,Div ("",[],[])
   [Para [Str "Returns",Str " ",Str "the",Str " ",Str "contained",Str " ",Span ("",[],[]) [Code ("",[],[]) "Some"],Str " ",Str "value,",Str " ",Str "consuming",Str " ",Str "the",Str " ",Code ("",[],[]) "self",Str " ",Str "value."]
   ,Div ("",[],[])
    [Null
    ,Null]
   ,Para [Str "Panics",Str " ",Str "if",Str " ",Str "the",Str " ",Str "value",Str " ",Str "is",Str " ",Str "a",Str " ",Span ("",[],[]) [Code ("",[],[]) "None"],Str " ",Str "with",Str " ",Str "a",Str " ",Str "custom",Str " ",Str "panic",Str " ",Str "message",Str " ",Str "provided",Str " ",Str "by",Str " ",Code ("",[],[]) "msg",Str "."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let x = Some(\"value\");\nassert_eq!(x.expect(\"fruits are healthy\"), \"value\");",Str "\n#+END_SRC"]
    ,Null]
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let x: Option<&str> = None;\nx.expect(\"fruits are healthy\"); // panics with `fruits are healthy`",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("unwrap.v",[],[]) "pub fn unwrap(self) -> T"]
  ,Div ("",[],[])
   [Para [Str "Returns",Str " ",Str "the",Str " ",Str "contained",Str " ",Span ("",[],[]) [Code ("",[],[]) "Some"],Str " ",Str "value,",Str " ",Str "consuming",Str " ",Str "the",Str " ",Code ("",[],[]) "self",Str " ",Str "value."]
   ,Para [Str "Because",Str " ",Str "this",Str " ",Str "function",Str " ",Str "may",Str " ",Str "panic,",Str " ",Str "its",Str " ",Str "use",Str " ",Str "is",Str " ",Str "generally",Str " ",Str "discouraged.",Str " ",Str "Instead,",Str " ",Str "prefer",Str " ",Str "to",Str " ",Str "use",Str " ",Str "pattern",Str " ",Str "matching",Str " ",Str "and",Str " ",Str "handle",Str " ",Str "the",Str " ",Span ("",[],[]) [Code ("",[],[]) "None"],Str " ",Str "case",Str " ",Str "explicitly,",Str " ",Str "or",Str " ",Str "call",Str " ",Span ("",[],[]) [Code ("",[],[]) "unwrap_or"],Str ",",Str " ",Span ("",[],[]) [Code ("",[],[]) "unwrap_or_else"],Str ",",Str " ",Str "or",Str " ",Span ("",[],[]) [Code ("",[],[]) "unwrap_or_default"],Str "."]
   ,Div ("",[],[])
    [Null
    ,Null]
   ,Para [Str "Panics",Str " ",Str "if",Str " ",Str "the",Str " ",Str "self",Str " ",Str "value",Str " ",Str "equals",Str " ",Span ("",[],[]) [Code ("",[],[]) "None"],Str "."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let x = Some(\"air\");\nassert_eq!(x.unwrap(), \"air\");",Str "\n#+END_SRC"]
    ,Null]
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let x: Option<&str> = None;\nassert_eq!(x.unwrap(), \"air\"); // fails",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("unwrap_or.v",[],[]) "pub fn unwrap_or(self, default: T) -> T"]
  ,Div ("",[],[])
   [Para [Str "Returns",Str " ",Str "the",Str " ",Str "contained",Str " ",Span ("",[],[]) [Code ("",[],[]) "Some"],Str " ",Str "value",Str " ",Str "or",Str " ",Str "a",Str " ",Str "provided",Str " ",Str "default."]
   ,Para [Str "Arguments",Str " ",Str "passed",Str " ",Str "to",Str " ",Code ("",[],[]) "unwrap_or",Str " ",Str "are",Str " ",Str "eagerly",Str " ",Str "evaluated;",Str " ",Str "if",Str " ",Str "you",Str " ",Str "are",Str " ",Str "passing",Str " ",Str "the",Str " ",Str "result",Str " ",Str "of",Str " ",Str "a",Str " ",Str "function",Str " ",Str "call,",Str " ",Str "it",Str " ",Str "is",Str " ",Str "recommended",Str " ",Str "to",Str " ",Str "use",Str " ",Span ("",[],[]) [Code ("",[],[]) "unwrap_or_else"],Str ",",Str " ",Str "which",Str " ",Str "is",Str " ",Str "lazily",Str " ",Str "evaluated."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "assert_eq!(Some(\"car\").unwrap_or(\"bike\"), \"car\");\nassert_eq!(None.unwrap_or(\"bike\"), \"bike\");",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("unwrap_or_else.v",[],[]) "pub fn unwrap_or_else<F>(self, f: F) -> T where\160\160\160\160F: FnOnce() -> T,\160"]
  ,Div ("",[],[])
   [Para [Str "Returns",Str " ",Str "the",Str " ",Str "contained",Str " ",Span ("",[],[]) [Code ("",[],[]) "Some"],Str " ",Str "value",Str " ",Str "or",Str " ",Str "computes",Str " ",Str "it",Str " ",Str "from",Str " ",Str "a",Str " ",Str "closure."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let k = 10;\nassert_eq!(Some(4).unwrap_or_else(|| 2 * k), 4);\nassert_eq!(None.unwrap_or_else(|| 2 * k), 20);",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("map.v",[],[]) "pub fn map<U, F>(self, f: F) -> Option<U> where\160\160\160\160F: FnOnce(T) -> U,\160"]
  ,Div ("",[],[])
   [Para [Str "Maps",Str " ",Str "an",Str " ",Code ("",[],[]) "Option<T>",Str " ",Str "to",Str " ",Code ("",[],[]) "Option<U>",Str " ",Str "by",Str " ",Str "applying",Str " ",Str "a",Str " ",Str "function",Str " ",Str "to",Str " ",Str "a",Str " ",Str "contained",Str " ",Str "value."]
   ,Null
   ,Para [Str "Converts",Str " ",Str "an",Str " ",Code ("",[],[]) "Option<",Span ("",[],[]) [Code ("",[],[]) "String"],Code ("",[],[]) ">",Str " ",Str "into",Str " ",Str "an",Str " ",Code ("",[],[]) "Option<",Span ("",[],[]) [Code ("",[],[]) "usize"],Code ("",[],[]) ">",Str ",",Str " ",Str "consuming",Str " ",Str "the",Str " ",Str "original:"]
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let maybe_some_string = Some(String::from(\"Hello, World!\"));\n// `Option::map` takes self *by value*, consuming `maybe_some_string`\nlet maybe_some_len = maybe_some_string.map(|s| s.len());\n\nassert_eq!(maybe_some_len, Some(13));",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("map_or.v",[],[]) "pub fn map_or<U, F>(self, default: U, f: F) -> U where\160\160\160\160F: FnOnce(T) -> U,\160"]
  ,Div ("",[],[])
   [Para [Str "Applies",Str " ",Str "a",Str " ",Str "function",Str " ",Str "to",Str " ",Str "the",Str " ",Str "contained",Str " ",Str "value",Str " ",Str "(if",Str " ",Str "any),",Str " ",Str "or",Str " ",Str "returns",Str " ",Str "the",Str " ",Str "provided",Str " ",Str "default",Str " ",Str "(if",Str " ",Str "not)."]
   ,Para [Str "Arguments",Str " ",Str "passed",Str " ",Str "to",Str " ",Code ("",[],[]) "map_or",Str " ",Str "are",Str " ",Str "eagerly",Str " ",Str "evaluated;",Str " ",Str "if",Str " ",Str "you",Str " ",Str "are",Str " ",Str "passing",Str " ",Str "the",Str " ",Str "result",Str " ",Str "of",Str " ",Str "a",Str " ",Str "function",Str " ",Str "call,",Str " ",Str "it",Str " ",Str "is",Str " ",Str "recommended",Str " ",Str "to",Str " ",Str "use",Str " ",Span ("",[],[]) [Code ("",[],[]) "map_or_else"],Str ",",Str " ",Str "which",Str " ",Str "is",Str " ",Str "lazily",Str " ",Str "evaluated."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let x = Some(\"foo\");\nassert_eq!(x.map_or(42, |v| v.len()), 3);\n\nlet x: Option<&str> = None;\nassert_eq!(x.map_or(42, |v| v.len()), 42);",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("map_or_else.v",[],[]) "pub fn map_or_else<U, D, F>(self, default: D, f: F) -> U where\160\160\160\160D: FnOnce() -> U,\160\160\160\160F: FnOnce(T) -> U,\160"]
  ,Div ("",[],[])
   [Para [Str "Applies",Str " ",Str "a",Str " ",Str "function",Str " ",Str "to",Str " ",Str "the",Str " ",Str "contained",Str " ",Str "value",Str " ",Str "(if",Str " ",Str "any),",Str " ",Str "or",Str " ",Str "computes",Str " ",Str "a",Str " ",Str "default",Str " ",Str "(if",Str " ",Str "not)."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let k = 21;\n\nlet x = Some(\"foo\");\nassert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 3);\n\nlet x: Option<&str> = None;\nassert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 42);",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("ok_or.v",[],[]) "pub fn ok_or<E>(self, err: E) -> Result<T, E>"]
  ,Div ("",[],[])
   [Para [Str "Transforms",Str " ",Str "the",Str " ",Code ("",[],[]) "Option<T>",Str " ",Str "into",Str " ",Str "a",Str " ",Span ("",[],[]) [Code ("",[],[]) "Result<T, E>"],Str ",",Str " ",Str "mapping",Str " ",Span ("",[],[]) [Code ("",[],[]) "Some(v)"],Str " ",Str "to",Str " ",Span ("",[],[]) [Code ("",[],[]) "Ok(v)"],Str " ",Str "and",Str " ",Span ("",[],[]) [Code ("",[],[]) "None"],Str " ",Str "to",Str " ",Span ("",[],[]) [Code ("",[],[]) "Err(err)"],Str "."]
   ,Para [Str "Arguments",Str " ",Str "passed",Str " ",Str "to",Str " ",Code ("",[],[]) "ok_or",Str " ",Str "are",Str " ",Str "eagerly",Str " ",Str "evaluated;",Str " ",Str "if",Str " ",Str "you",Str " ",Str "are",Str " ",Str "passing",Str " ",Str "the",Str " ",Str "result",Str " ",Str "of",Str " ",Str "a",Str " ",Str "function",Str " ",Str "call,",Str " ",Str "it",Str " ",Str "is",Str " ",Str "recommended",Str " ",Str "to",Str " ",Str "use",Str " ",Span ("",[],[]) [Code ("",[],[]) "ok_or_else"],Str ",",Str " ",Str "which",Str " ",Str "is",Str " ",Str "lazily",Str " ",Str "evaluated."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let x = Some(\"foo\");\nassert_eq!(x.ok_or(0), Ok(\"foo\"));\n\nlet x: Option<&str> = None;\nassert_eq!(x.ok_or(0), Err(0));",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("ok_or_else.v",[],[]) "pub fn ok_or_else<E, F>(self, err: F) -> Result<T, E> where\160\160\160\160F: FnOnce() -> E,\160"]
  ,Div ("",[],[])
   [Para [Str "Transforms",Str " ",Str "the",Str " ",Code ("",[],[]) "Option<T>",Str " ",Str "into",Str " ",Str "a",Str " ",Span ("",[],[]) [Code ("",[],[]) "Result<T, E>"],Str ",",Str " ",Str "mapping",Str " ",Span ("",[],[]) [Code ("",[],[]) "Some(v)"],Str " ",Str "to",Str " ",Span ("",[],[]) [Code ("",[],[]) "Ok(v)"],Str " ",Str "and",Str " ",Span ("",[],[]) [Code ("",[],[]) "None"],Str " ",Str "to",Str " ",Span ("",[],[]) [Code ("",[],[]) "Err(err())"],Str "."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let x = Some(\"foo\");\nassert_eq!(x.ok_or_else(|| 0), Ok(\"foo\"));\n\nlet x: Option<&str> = None;\nassert_eq!(x.ok_or_else(|| 0), Err(0));",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("iter.v",[],[]) "pub fn iter(&self) -> Iter<T>"]
  ,Div ("",[],[])
   [Para [Str "Returns",Str " ",Str "an",Str " ",Str "iterator",Str " ",Str "over",Str " ",Str "the",Str " ",Str "possibly",Str " ",Str "contained",Str " ",Str "value."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let x = Some(4);\nassert_eq!(x.iter().next(), Some(&4));\n\nlet x: Option<u32> = None;\nassert_eq!(x.iter().next(), None);",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("iter_mut.v",[],[]) "pub fn iter_mut(&mut self) -> IterMut<T>"]
  ,Div ("",[],[])
   [Para [Str "Returns",Str " ",Str "a",Str " ",Str "mutable",Str " ",Str "iterator",Str " ",Str "over",Str " ",Str "the",Str " ",Str "possibly",Str " ",Str "contained",Str " ",Str "value."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let mut x = Some(4);\nmatch x.iter_mut().next() {\n    Some(v) => *v = 42,\n    None => {},\n}\nassert_eq!(x, Some(42));\n\nlet mut x: Option<u32> = None;\nassert_eq!(x.iter_mut().next(), None);",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("and.v",[],[]) "pub fn and<U>(self, optb: Option<U>) -> Option<U>"]
  ,Div ("",[],[])
   [Para [Str "Returns",Str " ",Span ("",[],[]) [Code ("",[],[]) "None"],Str " ",Str "if",Str " ",Str "the",Str " ",Str "option",Str " ",Str "is",Str " ",Span ("",[],[]) [Code ("",[],[]) "None"],Str ",",Str " ",Str "otherwise",Str " ",Str "returns",Str " ",Code ("",[],[]) "optb",Str "."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let x = Some(2);\nlet y: Option<&str> = None;\nassert_eq!(x.and(y), None);\n\nlet x: Option<u32> = None;\nlet y = Some(\"foo\");\nassert_eq!(x.and(y), None);\n\nlet x = Some(2);\nlet y = Some(\"foo\");\nassert_eq!(x.and(y), Some(\"foo\"));\n\nlet x: Option<u32> = None;\nlet y: Option<&str> = None;\nassert_eq!(x.and(y), None);",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("and_then.v",[],[]) "pub fn and_then<U, F>(self, f: F) -> Option<U> where\160\160\160\160F: FnOnce(T) -> Option<U>,\160"]
  ,Div ("",[],[])
   [Para [Str "Returns",Str " ",Span ("",[],[]) [Code ("",[],[]) "None"],Str " ",Str "if",Str " ",Str "the",Str " ",Str "option",Str " ",Str "is",Str " ",Span ("",[],[]) [Code ("",[],[]) "None"],Str ",",Str " ",Str "otherwise",Str " ",Str "calls",Str " ",Code ("",[],[]) "f",Str " ",Str "with",Str " ",Str "the",Str " ",Str "wrapped",Str " ",Str "value",Str " ",Str "and",Str " ",Str "returns",Str " ",Str "the",Str " ",Str "result."]
   ,Para [Str "Some",Str " ",Str "languages",Str " ",Str "call",Str " ",Str "this",Str " ",Str "operation",Str " ",Str "flatmap."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "fn sq(x: u32) -> Option<u32> { Some(x * x) }\nfn nope(_: u32) -> Option<u32> { None }\n\nassert_eq!(Some(2).and_then(sq).and_then(sq), Some(16));\nassert_eq!(Some(2).and_then(sq).and_then(nope), None);\nassert_eq!(Some(2).and_then(nope).and_then(sq), None);\nassert_eq!(None.and_then(sq).and_then(sq), None);",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("filter.v",[],[]) "pub fn filter<P>(self, predicate: P) -> Option<T> where\160\160\160\160P: FnOnce(&T) -> bool,\160"]
  ,Div ("",[],[])
   [Para [Str "Returns",Str " ",Span ("",[],[]) [Code ("",[],[]) "None"],Str " ",Str "if",Str " ",Str "the",Str " ",Str "option",Str " ",Str "is",Str " ",Span ("",[],[]) [Code ("",[],[]) "None"],Str ",",Str " ",Str "otherwise",Str " ",Str "calls",Str " ",Code ("",[],[]) "predicate",Str " ",Str "with",Str " ",Str "the",Str " ",Str "wrapped",Str " ",Str "value",Str " ",Str "and",Str " ",Str "returns:"]
   ,BulletList
    [[Plain [Span ("",[],[]) [Code ("",[],[]) "Some(t)"]]
     ,Plain [Str " ",Str "if",Str " ",Code ("",[],[]) "predicate",Str " ",Str "returns",Str " ",Code ("",[],[]) "true",Str " ",Str "(where",Str " ",Code ("",[],[]) "t",Str " ",Str "is",Str " ",Str "the",Str " ",Str "wrapped",Str " ",Str "value),",Str " ",Str "and"]]
    ,[Plain [Span ("",[],[]) [Code ("",[],[]) "None"]]
     ,Plain [Str " ",Str "if",Str " ",Code ("",[],[]) "predicate",Str " ",Str "returns",Str " ",Code ("",[],[]) "false",Str "."]]]
   ,Para [Str "This",Str " ",Str "function",Str " ",Str "works",Str " ",Str "similar",Str " ",Str "to",Str " ",Span ("",[],[]) [Code ("",[],[]) "Iterator::filter()"],Str ".",Str " ",Str "You",Str " ",Str "can",Str " ",Str "imagine",Str " ",Str "the",Str " ",Code ("",[],[]) "Option<T>",Str " ",Str "being",Str " ",Str "an",Str " ",Str "iterator",Str " ",Str "over",Str " ",Str "one",Str " ",Str "or",Str " ",Str "zero",Str " ",Str "elements.",Str " ",Code ("",[],[]) "filter()",Str " ",Str "lets",Str " ",Str "you",Str " ",Str "decide",Str " ",Str "which",Str " ",Str "elements",Str " ",Str "to",Str " ",Str "keep."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "fn is_even(n: &i32) -> bool {\n    n % 2 == 0\n}\n\nassert_eq!(None.filter(is_even), None);\nassert_eq!(Some(3).filter(is_even), None);\nassert_eq!(Some(4).filter(is_even), Some(4));",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("or.v",[],[]) "pub fn or(self, optb: Option<T>) -> Option<T>"]
  ,Div ("",[],[])
   [Para [Str "Returns",Str " ",Str "the",Str " ",Str "option",Str " ",Str "if",Str " ",Str "it",Str " ",Str "contains",Str " ",Str "a",Str " ",Str "value,",Str " ",Str "otherwise",Str " ",Str "returns",Str " ",Code ("",[],[]) "optb",Str "."]
   ,Para [Str "Arguments",Str " ",Str "passed",Str " ",Str "to",Str " ",Code ("",[],[]) "or",Str " ",Str "are",Str " ",Str "eagerly",Str " ",Str "evaluated;",Str " ",Str "if",Str " ",Str "you",Str " ",Str "are",Str " ",Str "passing",Str " ",Str "the",Str " ",Str "result",Str " ",Str "of",Str " ",Str "a",Str " ",Str "function",Str " ",Str "call,",Str " ",Str "it",Str " ",Str "is",Str " ",Str "recommended",Str " ",Str "to",Str " ",Str "use",Str " ",Span ("",[],[]) [Code ("",[],[]) "or_else"],Str ",",Str " ",Str "which",Str " ",Str "is",Str " ",Str "lazily",Str " ",Str "evaluated."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let x = Some(2);\nlet y = None;\nassert_eq!(x.or(y), Some(2));\n\nlet x = None;\nlet y = Some(100);\nassert_eq!(x.or(y), Some(100));\n\nlet x = Some(2);\nlet y = Some(100);\nassert_eq!(x.or(y), Some(2));\n\nlet x: Option<u32> = None;\nlet y = None;\nassert_eq!(x.or(y), None);",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("or_else.v",[],[]) "pub fn or_else<F>(self, f: F) -> Option<T> where\160\160\160\160F: FnOnce() -> Option<T>,\160"]
  ,Div ("",[],[])
   [Para [Str "Returns",Str " ",Str "the",Str " ",Str "option",Str " ",Str "if",Str " ",Str "it",Str " ",Str "contains",Str " ",Str "a",Str " ",Str "value,",Str " ",Str "otherwise",Str " ",Str "calls",Str " ",Code ("",[],[]) "f",Str " ",Str "and",Str " ",Str "returns",Str " ",Str "the",Str " ",Str "result."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "fn nobody() -> Option<&'static str> { None }\nfn vikings() -> Option<&'static str> { Some(\"vikings\") }\n\nassert_eq!(Some(\"barbarians\").or_else(vikings), Some(\"barbarians\"));\nassert_eq!(None.or_else(vikings), Some(\"vikings\"));\nassert_eq!(None.or_else(nobody), None);",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("xor.v",[],[]) "pub fn xor(self, optb: Option<T>) -> Option<T>"]
  ,Div ("",[],[])
   [Para [Str "Returns",Str " ",Span ("",[],[]) [Code ("",[],[]) "Some"],Str " ",Str "if",Str " ",Str "exactly",Str " ",Str "one",Str " ",Str "of",Str " ",Code ("",[],[]) "self",Str ",",Str " ",Code ("",[],[]) "optb",Str " ",Str "is",Str " ",Span ("",[],[]) [Code ("",[],[]) "Some"],Str ",",Str " ",Str "otherwise",Str " ",Str "returns",Str " ",Span ("",[],[]) [Code ("",[],[]) "None"],Str "."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let x = Some(2);\nlet y: Option<u32> = None;\nassert_eq!(x.xor(y), Some(2));\n\nlet x: Option<u32> = None;\nlet y = Some(2);\nassert_eq!(x.xor(y), Some(2));\n\nlet x = Some(2);\nlet y = Some(2);\nassert_eq!(x.xor(y), None);\n\nlet x: Option<u32> = None;\nlet y: Option<u32> = None;\nassert_eq!(x.xor(y), None);",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("get_or_insert.v",[],[]) "pub fn get_or_insert(&mut self, v: T) -> &mut T"]
  ,Div ("",[],[])
   [Para [Str "Inserts",Str " ",Code ("",[],[]) "v",Str " ",Str "into",Str " ",Str "the",Str " ",Str "option",Str " ",Str "if",Str " ",Str "it",Str " ",Str "is",Str " ",Span ("",[],[]) [Code ("",[],[]) "None"],Str ",",Str " ",Str "then",Str " ",Str "returns",Str " ",Str "a",Str " ",Str "mutable",Str " ",Str "reference",Str " ",Str "to",Str " ",Str "the",Str " ",Str "contained",Str " ",Str "value."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let mut x = None;\n\n{\n    let y: &mut u32 = x.get_or_insert(5);\n    assert_eq!(y, &5);\n\n    *y = 7;\n}\n\nassert_eq!(x, Some(7));",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("get_or_insert_with.v",[],[]) "pub fn get_or_insert_with<F>(&mut self, f: F) -> &mut T where\160\160\160\160F: FnOnce() -> T,\160"]
  ,Div ("",[],[])
   [Para [Str "Inserts",Str " ",Str "a",Str " ",Str "value",Str " ",Str "computed",Str " ",Str "from",Str " ",Code ("",[],[]) "f",Str " ",Str "into",Str " ",Str "the",Str " ",Str "option",Str " ",Str "if",Str " ",Str "it",Str " ",Str "is",Str " ",Span ("",[],[]) [Code ("",[],[]) "None"],Str ",",Str " ",Str "then",Str " ",Str "returns",Str " ",Str "a",Str " ",Str "mutable",Str " ",Str "reference",Str " ",Str "to",Str " ",Str "the",Str " ",Str "contained",Str " ",Str "value."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let mut x = None;\n\n{\n    let y: &mut u32 = x.get_or_insert_with(|| 5);\n    assert_eq!(y, &5);\n\n    *y = 7;\n}\n\nassert_eq!(x, Some(7));",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("take.v",[],[]) "pub fn take(&mut self) -> Option<T>"]
  ,Div ("",[],[])
   [Para [Str "Takes",Str " ",Str "the",Str " ",Str "value",Str " ",Str "out",Str " ",Str "of",Str " ",Str "the",Str " ",Str "option,",Str " ",Str "leaving",Str " ",Str "a",Str " ",Span ("",[],[]) [Code ("",[],[]) "None"],Str " ",Str "in",Str " ",Str "its",Str " ",Str "place."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let mut x = Some(2);\nlet y = x.take();\nassert_eq!(x, None);\nassert_eq!(y, Some(2));\n\nlet mut x: Option<u32> = None;\nlet y = x.take();\nassert_eq!(x, None);\nassert_eq!(y, None);",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("replace.v",[],[]) "pub fn replace(&mut self, value: T) -> Option<T>"]
  ,Div ("",[],[])
   [Para [Str "Replaces",Str " ",Str "the",Str " ",Str "actual",Str " ",Str "value",Str " ",Str "in",Str " ",Str "the",Str " ",Str "option",Str " ",Str "by",Str " ",Str "the",Str " ",Str "value",Str " ",Str "given",Str " ",Str "in",Str " ",Str "parameter,",Str " ",Str "returning",Str " ",Str "the",Str " ",Str "old",Str " ",Str "value",Str " ",Str "if",Str " ",Str "present,",Str " ",Str "leaving",Str " ",Str "a",Str " ",Span ("",[],[]) [Code ("",[],[]) "Some"],Str " ",Str "in",Str " ",Str "its",Str " ",Str "place",Str " ",Str "without",Str " ",Str "deinitializing",Str " ",Str "either",Str " ",Str "one."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let mut x = Some(2);\nlet old = x.replace(5);\nassert_eq!(x, Some(5));\nassert_eq!(old, Some(2));\n\nlet mut x = None;\nlet old = x.replace(3);\nassert_eq!(x, Some(3));\nassert_eq!(old, None);",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("zip.v",[],[]) "pub fn zip<U>(self, other: Option<U>) -> Option<(T, U)>"]
  ,Plain [Str "This",Str " ",Str "is",Str " ",Str "a",Str " ",Str "nightly-only",Str " ",Str "experimental",Str " ",Str "API.",Str " ",Str "(",Code ("",[],[]) "option_zip",Str "\160",Span ("",[],[]) [Str "#70086"],Str ")",Str " "]
  ,Div ("",[],[])
   [Para [Str "Zips",Str " ",Code ("",[],[]) "self",Str " ",Str "with",Str " ",Str "another",Str " ",Code ("",[],[]) "Option",Str "."]
   ,Para [Str "If",Str " ",Code ("",[],[]) "self",Str " ",Str "is",Str " ",Code ("",[],[]) "Some(s)",Str " ",Str "and",Str " ",Code ("",[],[]) "other",Str " ",Str "is",Str " ",Code ("",[],[]) "Some(o)",Str ",",Str " ",Str "this",Str " ",Str "method",Str " ",Str "returns",Str " ",Code ("",[],[]) "Some((s, o))",Str ".",Str " ",Str "Otherwise,",Str " ",Code ("",[],[]) "None",Str " ",Str "is",Str " ",Str "returned."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "#![feature(option_zip)]\nlet x = Some(1);\nlet y = Some(\"hi\");\nlet z = None::<u8>;\n\nassert_eq!(x.zip(y), Some((1, \"hi\")));\nassert_eq!(x.zip(z), None);",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("zip_with.v",[],[]) "pub fn zip_with<U, F, R>(self, other: Option<U>, f: F) -> Option<R> where\160\160\160\160F: FnOnce(T, U) -> R,\160"]
  ,Plain [Str "This",Str " ",Str "is",Str " ",Str "a",Str " ",Str "nightly-only",Str " ",Str "experimental",Str " ",Str "API.",Str " ",Str "(",Code ("",[],[]) "option_zip",Str "\160",Span ("",[],[]) [Str "#70086"],Str ")",Str " "]
  ,Div ("",[],[])
   [Para [Str "Zips",Str " ",Code ("",[],[]) "self",Str " ",Str "and",Str " ",Str "another",Str " ",Code ("",[],[]) "Option",Str " ",Str "with",Str " ",Str "function",Str " ",Code ("",[],[]) "f",Str "."]
   ,Para [Str "If",Str " ",Code ("",[],[]) "self",Str " ",Str "is",Str " ",Code ("",[],[]) "Some(s)",Str " ",Str "and",Str " ",Code ("",[],[]) "other",Str " ",Str "is",Str " ",Code ("",[],[]) "Some(o)",Str ",",Str " ",Str "this",Str " ",Str "method",Str " ",Str "returns",Str " ",Code ("",[],[]) "Some(f(s, o))",Str ".",Str " ",Str "Otherwise,",Str " ",Code ("",[],[]) "None",Str " ",Str "is",Str " ",Str "returned."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "#![feature(option_zip)]\n\n#[derive(Debug, PartialEq)]\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\nimpl Point {\n    fn new(x: f64, y: f64) -> Self {\n        Self { x, y }\n    }\n}\n\nlet x = Some(17.5);\nlet y = Some(42.7);\n\nassert_eq!(x.zip_with(y, Point::new), Some(Point { x: 17.5, y: 42.7 }));\nassert_eq!(x.zip_with(None, Point::new), None);",Str "\n#+END_SRC"]
    ,Null]]]
 ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<'_, T> Option<&'_ T> where\160\160\160\160T: Copy,\160"]
 ,Div ("",["impl-items"],[])
  [Header 3 ("",[],[]) [Code ("copied.v",[],[]) "pub fn copied(self) -> Option<T>"]
  ,Div ("",[],[])
   [Para [Str "Maps",Str " ",Str "an",Str " ",Code ("",[],[]) "Option<&T>",Str " ",Str "to",Str " ",Str "an",Str " ",Code ("",[],[]) "Option<T>",Str " ",Str "by",Str " ",Str "copying",Str " ",Str "the",Str " ",Str "contents",Str " ",Str "of",Str " ",Str "the",Str " ",Str "option."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let x = 12;\nlet opt_x = Some(&x);\nassert_eq!(opt_x, Some(&12));\nlet copied = opt_x.copied();\nassert_eq!(copied, Some(12));",Str "\n#+END_SRC"]
    ,Null]]]
 ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<'_, T> Option<&'_ mut T> where\160\160\160\160T: Copy,\160"]
 ,Div ("",["impl-items"],[])
  [Header 3 ("",[],[]) [Code ("copied.v-1",[],[]) "pub fn copied(self) -> Option<T>"]
  ,Div ("",[],[])
   [Para [Str "Maps",Str " ",Str "an",Str " ",Code ("",[],[]) "Option<&mut T>",Str " ",Str "to",Str " ",Str "an",Str " ",Code ("",[],[]) "Option<T>",Str " ",Str "by",Str " ",Str "copying",Str " ",Str "the",Str " ",Str "contents",Str " ",Str "of",Str " ",Str "the",Str " ",Str "option."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let mut x = 12;\nlet opt_x = Some(&mut x);\nassert_eq!(opt_x, Some(&mut 12));\nlet copied = opt_x.copied();\nassert_eq!(copied, Some(12));",Str "\n#+END_SRC"]
    ,Null]]]
 ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<'_, T> Option<&'_ T> where\160\160\160\160T: Clone,\160"]
 ,Div ("",["impl-items"],[])
  [Header 3 ("",[],[]) [Code ("cloned.v",[],[]) "pub fn cloned(self) -> Option<T>"]
  ,Div ("",[],[])
   [Para [Str "Maps",Str " ",Str "an",Str " ",Code ("",[],[]) "Option<&T>",Str " ",Str "to",Str " ",Str "an",Str " ",Code ("",[],[]) "Option<T>",Str " ",Str "by",Str " ",Str "cloning",Str " ",Str "the",Str " ",Str "contents",Str " ",Str "of",Str " ",Str "the",Str " ",Str "option."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let x = 12;\nlet opt_x = Some(&x);\nassert_eq!(opt_x, Some(&12));\nlet cloned = opt_x.cloned();\nassert_eq!(cloned, Some(12));",Str "\n#+END_SRC"]
    ,Null]]]
 ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<'_, T> Option<&'_ mut T> where\160\160\160\160T: Clone,\160"]
 ,Div ("",["impl-items"],[])
  [Header 3 ("",[],[]) [Code ("cloned.v-1",[],[]) "pub fn cloned(self) -> Option<T>"]
  ,Div ("",[],[])
   [Para [Str "Maps",Str " ",Str "an",Str " ",Code ("",[],[]) "Option<&mut T>",Str " ",Str "to",Str " ",Str "an",Str " ",Code ("",[],[]) "Option<T>",Str " ",Str "by",Str " ",Str "cloning",Str " ",Str "the",Str " ",Str "contents",Str " ",Str "of",Str " ",Str "the",Str " ",Str "option."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let mut x = 12;\nlet opt_x = Some(&mut x);\nassert_eq!(opt_x, Some(&mut 12));\nlet cloned = opt_x.cloned();\nassert_eq!(cloned, Some(12));",Str "\n#+END_SRC"]
    ,Null]]]
 ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Option<T> where\160\160\160\160T: Debug,\160"]
 ,Div ("",["impl-items"],[])
  [Header 3 ("",[],[]) [Code ("expect_none.v",[],[]) "pub fn expect_none(self, msg: &str)"]
  ,Plain [Str "This",Str " ",Str "is",Str " ",Str "a",Str " ",Str "nightly-only",Str " ",Str "experimental",Str " ",Str "API.",Str " ",Str "(",Code ("",[],[]) "option_expect_none",Str "\160",Span ("",[],[]) [Str "#62633"],Str ")",Str " ",Str "newly",Str " ",Str "added"]
  ,Div ("",[],[])
   [Para [Str "Consumes",Str " ",Code ("",[],[]) "self",Str " ",Str "while",Str " ",Str "expecting",Str " ",Span ("",[],[]) [Code ("",[],[]) "None"],Str " ",Str "and",Str " ",Str "returning",Str " ",Str "nothing."]
   ,Div ("",[],[])
    [Null
    ,Null]
   ,Para [Str "Panics",Str " ",Str "if",Str " ",Str "the",Str " ",Str "value",Str " ",Str "is",Str " ",Str "a",Str " ",Span ("",[],[]) [Code ("",[],[]) "Some"],Str ",",Str " ",Str "with",Str " ",Str "a",Str " ",Str "panic",Str " ",Str "message",Str " ",Str "including",Str " ",Str "the",Str " ",Str "passed",Str " ",Str "message,",Str " ",Str "and",Str " ",Str "the",Str " ",Str "content",Str " ",Str "of",Str " ",Str "the",Str " ",Span ("",[],[]) [Code ("",[],[]) "Some"],Str "."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "#![feature(option_expect_none)]\n\nuse std::collections::HashMap;\nlet mut squares = HashMap::new();\nfor i in -10..=10 {\n    // This will not panic, since all keys are unique.\n    squares.insert(i, i * i).expect_none(\"duplicate key\");\n}",Str "\n#+END_SRC"]
    ,Null]
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "#![feature(option_expect_none)]\n\nuse std::collections::HashMap;\nlet mut sqrts = HashMap::new();\nfor i in -10..=10 {\n    // This will panic, since both negative and positive `i` will\n    // insert the same `i * i` key, returning the old `Some(i)`.\n    sqrts.insert(i * i, i).expect_none(\"duplicate key\");\n}",Str "\n#+END_SRC"]
    ,Null]]
  ,Header 3 ("",[],[]) [Code ("unwrap_none.v",[],[]) "pub fn unwrap_none(self)"]
  ,Plain [Str "This",Str " ",Str "is",Str " ",Str "a",Str " ",Str "nightly-only",Str " ",Str "experimental",Str " ",Str "API.",Str " ",Str "(",Code ("",[],[]) "option_unwrap_none",Str "\160",Span ("",[],[]) [Str "#62633"],Str ")",Str " ",Str "newly",Str " ",Str "added"]
  ,Div ("",[],[])
   [Para [Str "Consumes",Str " ",Code ("",[],[]) "self",Str " ",Str "while",Str " ",Str "expecting",Str " ",Span ("",[],[]) [Code ("",[],[]) "None"],Str " ",Str "and",Str " ",Str "returning",Str " ",Str "nothing."]
   ,Div ("",[],[])
    [Null
    ,Null]
   ,Para [Str "Panics",Str " ",Str "if",Str " ",Str "the",Str " ",Str "value",Str " ",Str "is",Str " ",Str "a",Str " ",Span ("",[],[]) [Code ("",[],[]) "Some"],Str ",",Str " ",Str "with",Str " ",Str "a",Str " ",Str "custom",Str " ",Str "panic",Str " ",Str "message",Str " ",Str "provided",Str " ",Str "by",Str " ",Str "the",Str " ",Span ("",[],[]) [Code ("",[],[]) "Some"],Str "'s",Str " ",Str "value."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "#![feature(option_unwrap_none)]\n\nuse std::collections::HashMap;\nlet mut squares = HashMap::new();\nfor i in -10..=10 {\n    // This will not panic, since all keys are unique.\n    squares.insert(i, i * i).unwrap_none();\n}",Str "\n#+END_SRC"]
    ,Null]
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "#![feature(option_unwrap_none)]\n\nuse std::collections::HashMap;\nlet mut sqrts = HashMap::new();\nfor i in -10..=10 {\n    // This will panic, since both negative and positive `i` will\n    // insert the same `i * i` key, returning the old `Some(i)`.\n    sqrts.insert(i * i, i).unwrap_none();\n}",Str "\n#+END_SRC"]
    ,Null]]]
 ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Option<T> where\160\160\160\160T: Default,\160"]
 ,Div ("",["impl-items"],[])
  [Header 3 ("",[],[]) [Code ("unwrap_or_default.v",[],[]) "pub fn unwrap_or_default(self) -> T"]
  ,Div ("",[],[])
   [Para [Str "Returns",Str " ",Str "the",Str " ",Str "contained",Str " ",Span ("",[],[]) [Code ("",[],[]) "Some"],Str " ",Str "value",Str " ",Str "or",Str " ",Str "a",Str " ",Str "default"]
   ,Para [Str "Consumes",Str " ",Str "the",Str " ",Code ("",[],[]) "self",Str " ",Str "argument",Str " ",Str "then,",Str " ",Str "if",Str " ",Span ("",[],[]) [Code ("",[],[]) "Some"],Str ",",Str " ",Str "returns",Str " ",Str "the",Str " ",Str "contained",Str " ",Str "value,",Str " ",Str "otherwise",Str " ",Str "if",Str " ",Span ("",[],[]) [Code ("",[],[]) "None"],Str ",",Str " ",Str "returns",Str " ",Str "the",Str " ",Span ("",[],[]) [Str "default",Str " ",Str "value"],Str " ",Str "for",Str " ",Str "that",Str " ",Str "type."]
   ,Null
   ,Para [Str "Converts",Str " ",Str "a",Str " ",Str "string",Str " ",Str "to",Str " ",Str "an",Str " ",Str "integer,",Str " ",Str "turning",Str " ",Str "poorly-formed",Str " ",Str "strings",Str " ",Str "into",Str " ",Str "0",Str " ",Str "(the",Str " ",Str "default",Str " ",Str "value",Str " ",Str "for",Str " ",Str "integers).",Str " ",Span ("",[],[]) [Code ("",[],[]) "parse"],Str " ",Str "converts",Str " ",Str "a",Str " ",Str "string",Str " ",Str "to",Str " ",Str "any",Str " ",Str "other",Str " ",Str "type",Str " ",Str "that",Str " ",Str "implements",Str " ",Span ("",[],[]) [Code ("",[],[]) "FromStr"],Str ",",Str " ",Str "returning",Str " ",Span ("",[],[]) [Code ("",[],[]) "None"],Str " ",Str "on",Str " ",Str "error."]
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let good_year_from_input = \"1909\";\nlet bad_year_from_input = \"190blarg\";\nlet good_year = good_year_from_input.parse().ok().unwrap_or_default();\nlet bad_year = bad_year_from_input.parse().ok().unwrap_or_default();\n\nassert_eq!(1909, good_year);\nassert_eq!(0, bad_year);",Str "\n#+END_SRC"]
    ,Null]]]
 ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Option<T> where\160\160\160\160T: Deref,\160"]
 ,Div ("",["impl-items"],[])
  [Header 3 ("",[],[]) [Code ("as_deref.v",[],[]) "pub fn as_deref(&self) -> Option<&<T as Deref>::Target>"]
  ,Div ("",[],[])
   [Para [Str "Converts",Str " ",Str "from",Str " ",Code ("",[],[]) "Option<T>",Str " ",Str "(or",Str " ",Code ("",[],[]) "&Option<T>",Str ")",Str " ",Str "to",Str " ",Code ("",[],[]) "Option<&T::Target>",Str "."]
   ,Para [Str "Leaves",Str " ",Str "the",Str " ",Str "original",Str " ",Str "Option",Str " ",Str "in-place,",Str " ",Str "creating",Str " ",Str "a",Str " ",Str "new",Str " ",Str "one",Str " ",Str "with",Str " ",Str "a",Str " ",Str "reference",Str " ",Str "to",Str " ",Str "the",Str " ",Str "original",Str " ",Str "one,",Str " ",Str "additionally",Str " ",Str "coercing",Str " ",Str "the",Str " ",Str "contents",Str " ",Str "via",Str " ",Span ("",[],[]) [Code ("",[],[]) "Deref"],Str "."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let x: Option<String> = Some(\"hey\".to_owned());\nassert_eq!(x.as_deref(), Some(\"hey\"));\n\nlet x: Option<String> = None;\nassert_eq!(x.as_deref(), None);",Str "\n#+END_SRC"]
    ,Null]]]
 ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Option<T> where\160\160\160\160T: DerefMut,\160"]
 ,Div ("",["impl-items"],[])
  [Header 3 ("",[],[]) [Code ("as_deref_mut.v",[],[]) "pub fn as_deref_mut(&mut self) -> Option<&mut <T as Deref>::Target>"]
  ,Div ("",[],[])
   [Para [Str "Converts",Str " ",Str "from",Str " ",Code ("",[],[]) "Option<T>",Str " ",Str "(or",Str " ",Code ("",[],[]) "&mut Option<T>",Str ")",Str " ",Str "to",Str " ",Code ("",[],[]) "Option<&mut T::Target>",Str "."]
   ,Para [Str "Leaves",Str " ",Str "the",Str " ",Str "original",Str " ",Code ("",[],[]) "Option",Str " ",Str "in-place,",Str " ",Str "creating",Str " ",Str "a",Str " ",Str "new",Str " ",Str "one",Str " ",Str "containing",Str " ",Str "a",Str " ",Str "mutable",Str " ",Str "reference",Str " ",Str "to",Str " ",Str "the",Str " ",Str "inner",Str " ",Str "type's",Str " ",Code ("",[],[]) "Deref::Target",Str " ",Str "type."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let mut x: Option<String> = Some(\"hey\".to_owned());\nassert_eq!(x.as_deref_mut().map(|x| {\n    x.make_ascii_uppercase();\n    x\n}), Some(\"HEY\".to_owned().as_mut_str()));",Str "\n#+END_SRC"]
    ,Null]]]
 ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T, E> Option<Result<T, E>>"]
 ,Div ("",["impl-items"],[])
  [Header 3 ("",[],[]) [Code ("transpose.v",[],[]) "pub fn transpose(self) -> Result<Option<T>, E>"]
  ,Div ("",[],[])
   [Para [Str "Transposes",Str " ",Str "an",Str " ",Code ("",[],[]) "Option",Str " ",Str "of",Str " ",Str "a",Str " ",Span ("",[],[]) [Code ("",[],[]) "Result"],Str " ",Str "into",Str " ",Str "a",Str " ",Span ("",[],[]) [Code ("",[],[]) "Result"],Str " ",Str "of",Str " ",Str "an",Str " ",Code ("",[],[]) "Option",Str "."]
   ,Para [Span ("",[],[]) [Code ("",[],[]) "None"],Str " ",Str "will",Str " ",Str "be",Str " ",Str "mapped",Str " ",Str "to",Str " ",Span ("",[],[]) [Code ("",[],[]) "Ok"],Code ("",[],[]) "(",Span ("",[],[]) [Code ("",[],[]) "None"],Code ("",[],[]) ")",Str ".",Str " ",Span ("",[],[]) [Code ("",[],[]) "Some"],Code ("",[],[]) "(",Span ("",[],[]) [Code ("",[],[]) "Ok"],Code ("",[],[]) "(_))",Str " ",Str "and",Str " ",Span ("",[],[]) [Code ("",[],[]) "Some"],Code ("",[],[]) "(",Span ("",[],[]) [Code ("",[],[]) "Err"],Code ("",[],[]) "(_))",Str " ",Str "will",Str " ",Str "be",Str " ",Str "mapped",Str " ",Str "to",Str " ",Span ("",[],[]) [Code ("",[],[]) "Ok"],Code ("",[],[]) "(",Span ("",[],[]) [Code ("",[],[]) "Some"],Code ("",[],[]) "(_))",Str " ",Str "and",Str " ",Span ("",[],[]) [Code ("",[],[]) "Err"],Code ("",[],[]) "(_)",Str "."]
   ,Null
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "#[derive(Debug, Eq, PartialEq)]\nstruct SomeErr;\n\nlet x: Result<Option<i32>, SomeErr> = Ok(Some(5));\nlet y: Option<Result<i32, SomeErr>> = Some(Ok(5));\nassert_eq!(x, y.transpose());",Str "\n#+END_SRC"]
    ,Null]]]
 ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Option<Option<T>>"]
 ,Div ("",["impl-items"],[])
  [Header 3 ("",[],[]) [Code ("flatten.v",[],[]) "pub fn flatten(self) -> Option<T>"]
  ,Div ("",[],[])
   [Para [Str "Converts",Str " ",Str "from",Str " ",Code ("",[],[]) "Option<Option<T>>",Str " ",Str "to",Str " ",Code ("",[],[]) "Option<T>"]
   ,Null
   ,Para [Str "Basic",Str " ",Str "usage:"]
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let x: Option<Option<u32>> = Some(Some(6));\nassert_eq!(Some(6), x.flatten());\n\nlet x: Option<Option<u32>> = Some(None);\nassert_eq!(None, x.flatten());\n\nlet x: Option<Option<u32>> = None;\nassert_eq!(None, x.flatten());",Str "\n#+END_SRC"]
    ,Null]
   ,Para [Str "Flattening",Str " ",Str "once",Str " ",Str "only",Str " ",Str "removes",Str " ",Str "one",Str " ",Str "level",Str " ",Str "of",Str " ",Str "nesting:"]
   ,Div ("",["example-wrap"],[])
    [Para [Str "#+BEGIN_SRC rust \n",Str "let x: Option<Option<Option<u32>>> = Some(Some(Some(6)));\nassert_eq!(Some(Some(6)), x.flatten());\nassert_eq!(Some(6), x.flatten().flatten());",Str "\n#+END_SRC"]
    ,Null]]]
 ,Header 1 ("",[],[]) [Str "Trait",Str " ",Str "Implementations"]
 ,Div ("trait-implementations-list",[],[])
  [Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Clone for Option<T> where\160\160\160\160T: Clone,\160"]
  ,Div ("",["impl-items"],[])
   [Header 3 ("",[],[]) [Code ("clone.v",[],[]) "fn clone(&self) -> Option<T>"]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "Returns",Str " ",Str "a",Str " ",Str "copy",Str " ",Str "of",Str " ",Str "the",Str " ",Str "value.",Str " ",Span ("",[],[]) [Str "Read",Str " ",Str "more"]]]
   ,Header 3 ("",[],[]) [Code ("clone_from.v",[],[]) "fn clone_from(&mut self, source: &Option<T>)"]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "Performs",Str " ",Str "copy-assignment",Str " ",Str "from",Str " ",Code ("",[],[]) "source",Str ".",Str " ",Span ("",[],[]) [Str "Read",Str " ",Str "more"]]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Copy for Option<T> where\160\160\160\160T: Copy,\160"]
  ,Div ("",["impl-items"],[])
   []
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Debug for Option<T> where\160\160\160\160T: Debug,\160"]
  ,Div ("",["impl-items"],[])
   [Header 3 ("",[],[]) [Code ("fmt.v",[],[]) "fn fmt(&self, f: &mut Formatter) -> Result<(), Error>"]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "Formats",Str " ",Str "the",Str " ",Str "value",Str " ",Str "using",Str " ",Str "the",Str " ",Str "given",Str " ",Str "formatter.",Str " ",Span ("",[],[]) [Str "Read",Str " ",Str "more"]]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Default for Option<T>"]
  ,Div ("",["impl-items"],[])
   [Header 3 ("",[],[]) [Code ("default.v",[],[]) "fn default() -> Option<T>"]
   ,Div ("",[],[])
    [Para [Str "Returns",Str " ",Span ("",[],[]) [Code ("",[],[]) "None"],Str "."]
    ,Null
    ,Div ("",["example-wrap"],[])
     [Para [Str "#+BEGIN_SRC rust \n",Str "let opt: Option<u32> = Option::default();\nassert!(opt.is_none());",Str "\n#+END_SRC"]
     ,Null]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Eq for Option<T> where\160\160\160\160T: Eq,\160"]
  ,Div ("",["impl-items"],[])
   []
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<'a, T> From<&'a Option<T>> for Option<&'a T>"]
  ,Div ("",["impl-items"],[])
   [Header 3 ("",[],[]) [Code ("from.v-2",[],[]) "fn from(o: &'a Option<T>) -> Option<&'a T>"]
   ,Div ("",[],[])
    [Para [Str "Converts",Str " ",Str "from",Str " ",Code ("",[],[]) "&Option<T>",Str " ",Str "to",Str " ",Code ("",[],[]) "Option<&T>",Str "."]
    ,Null
    ,Para [Str "Converts",Str " ",Str "an",Str " ",Code ("",[],[]) "Option<",Span ("",[],[]) [Code ("",[],[]) "String"],Code ("",[],[]) ">",Str " ",Str "into",Str " ",Str "an",Str " ",Code ("",[],[]) "Option<",Span ("",[],[]) [Code ("",[],[]) "usize"],Code ("",[],[]) ">",Str ",",Str " ",Str "preserving",Str " ",Str "the",Str " ",Str "original.",Str " ",Str "The",Str " ",Span ("",[],[]) [Code ("",[],[]) "map"],Str " ",Str "method",Str " ",Str "takes",Str " ",Str "the",Str " ",Code ("",[],[]) "self",Str " ",Str "argument",Str " ",Str "by",Str " ",Str "value,",Str " ",Str "consuming",Str " ",Str "the",Str " ",Str "original,",Str " ",Str "so",Str " ",Str "this",Str " ",Str "technique",Str " ",Str "uses",Str " ",Code ("",[],[]) "as_ref",Str " ",Str "to",Str " ",Str "first",Str " ",Str "take",Str " ",Str "an",Str " ",Code ("",[],[]) "Option",Str " ",Str "to",Str " ",Str "a",Str " ",Str "reference",Str " ",Str "to",Str " ",Str "the",Str " ",Str "value",Str " ",Str "inside",Str " ",Str "the",Str " ",Str "original."]
    ,Div ("",["example-wrap"],[])
     [Para [Str "#+BEGIN_SRC rust \n",Str "let s: Option<String> = Some(String::from(\"Hello, Rustaceans!\"));\nlet o: Option<usize> = Option::from(&s).map(|ss: &String| ss.len());\n\nprintln!(\"Can still print s: {:?}\", s);\n\nassert_eq!(o, Some(18));",Str "\n#+END_SRC"]
     ,Null]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<'a, T> From<&'a mut Option<T>> for Option<&'a mut T>"]
  ,Div ("",["impl-items"],[])
   [Header 3 ("",[],[]) [Code ("from.v-1",[],[]) "fn from(o: &'a mut Option<T>) -> Option<&'a mut T>"]
   ,Div ("",[],[])
    [Para [Str "Converts",Str " ",Str "from",Str " ",Code ("",[],[]) "&mut Option<T>",Str " ",Str "to",Str " ",Code ("",[],[]) "Option<&mut T>"]
    ,Null
    ,Div ("",["example-wrap"],[])
     [Para [Str "#+BEGIN_SRC rust \n",Str "let mut s = Some(String::from(\"Hello\"));\nlet o: Option<&mut String> = Option::from(&mut s);\n\nmatch o {\n    Some(t) => *t = String::from(\"Hello, Rustaceans!\"),\n    None => (),\n}\n\nassert_eq!(s, Some(String::from(\"Hello, Rustaceans!\")));",Str "\n#+END_SRC"]
     ,Null]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> From<T> for Option<T>"]
  ,Div ("",["impl-items"],[])
   [Header 3 ("",[],[]) [Code ("from.v",[],[]) "fn from(val: T) -> Option<T>"]
   ,Div ("",[],[])
    [Para [Str "Copies",Str " ",Code ("",[],[]) "val",Str " ",Str "into",Str " ",Str "a",Str " ",Str "new",Str " ",Code ("",[],[]) "Some",Str "."]
    ,Null
    ,Div ("",["example-wrap"],[])
     [Para [Str "#+BEGIN_SRC rust \n",Str "let o: Option<u8> = Option::from(67);\n\nassert_eq!(Some(67), o);",Str "\n#+END_SRC"]
     ,Null]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<A, V> FromIterator<Option<A>> for Option<V> where\160\160\160\160V: FromIterator<A>,\160"]
  ,Div ("",["impl-items"],[])
   [Header 3 ("",[],[]) [Code ("from_iter.v",[],[]) "fn from_iter<I>(iter: I) -> Option<V> where\160\160\160\160I: IntoIterator<Item = Option<A>>,\160"]
   ,Div ("",[],[])
    [Para [Str "Takes",Str " ",Str "each",Str " ",Str "element",Str " ",Str "in",Str " ",Str "the",Str " ",Span ("",[],[]) [Code ("",[],[]) "Iterator"],Str ":",Str " ",Str "if",Str " ",Str "it",Str " ",Str "is",Str " ",Span ("",[],[]) [Code ("",[],[]) "None"],Str ",",Str " ",Str "no",Str " ",Str "further",Str " ",Str "elements",Str " ",Str "are",Str " ",Str "taken,",Str " ",Str "and",Str " ",Str "the",Str " ",Span ("",[],[]) [Code ("",[],[]) "None"],Str " ",Str "is",Str " ",Str "returned.",Str " ",Str "Should",Str " ",Str "no",Str " ",Span ("",[],[]) [Code ("",[],[]) "None"],Str " ",Str "occur,",Str " ",Str "a",Str " ",Str "container",Str " ",Str "with",Str " ",Str "the",Str " ",Str "values",Str " ",Str "of",Str " ",Str "each",Str " ",Span ("",[],[]) [Code ("",[],[]) "Option"],Str " ",Str "is",Str " ",Str "returned."]
    ,Null
    ,Para [Str "Here",Str " ",Str "is",Str " ",Str "an",Str " ",Str "example",Str " ",Str "which",Str " ",Str "increments",Str " ",Str "every",Str " ",Str "integer",Str " ",Str "in",Str " ",Str "a",Str " ",Str "vector.",Str " ",Str "We",Str " ",Str "use",Str " ",Str "the",Str " ",Str "checked",Str " ",Str "variant",Str " ",Str "of",Str " ",Code ("",[],[]) "add",Str " ",Str "that",Str " ",Str "returns",Str " ",Code ("",[],[]) "None",Str " ",Str "when",Str " ",Str "the",Str " ",Str "calculation",Str " ",Str "would",Str " ",Str "result",Str " ",Str "in",Str " ",Str "an",Str " ",Str "overflow."]
    ,Div ("",["example-wrap"],[])
     [Para [Str "#+BEGIN_SRC rust \n",Str "let items = vec![0_u16, 1, 2];\n\nlet res: Option<Vec<u16>> = items\n    .iter()\n    .map(|x| x.checked_add(1))\n    .collect();\n\nassert_eq!(res, Some(vec![1, 2, 3]));",Str "\n#+END_SRC"]
     ,Null]
    ,Para [Str "As",Str " ",Str "you",Str " ",Str "can",Str " ",Str "see,",Str " ",Str "this",Str " ",Str "will",Str " ",Str "return",Str " ",Str "the",Str " ",Str "expected,",Str " ",Str "valid",Str " ",Str "items."]
    ,Para [Str "Here",Str " ",Str "is",Str " ",Str "another",Str " ",Str "example",Str " ",Str "that",Str " ",Str "tries",Str " ",Str "to",Str " ",Str "subtract",Str " ",Str "one",Str " ",Str "from",Str " ",Str "another",Str " ",Str "list",Str " ",Str "of",Str " ",Str "integers,",Str " ",Str "this",Str " ",Str "time",Str " ",Str "checking",Str " ",Str "for",Str " ",Str "underflow:"]
    ,Div ("",["example-wrap"],[])
     [Para [Str "#+BEGIN_SRC rust \n",Str "let items = vec![2_u16, 1, 0];\n\nlet res: Option<Vec<u16>> = items\n    .iter()\n    .map(|x| x.checked_sub(1))\n    .collect();\n\nassert_eq!(res, None);",Str "\n#+END_SRC"]
     ,Null]
    ,Para [Str "Since",Str " ",Str "the",Str " ",Str "last",Str " ",Str "element",Str " ",Str "is",Str " ",Str "zero,",Str " ",Str "it",Str " ",Str "would",Str " ",Str "underflow.",Str " ",Str "Thus,",Str " ",Str "the",Str " ",Str "resulting",Str " ",Str "value",Str " ",Str "is",Str " ",Code ("",[],[]) "None",Str "."]
    ,Para [Str "Here",Str " ",Str "is",Str " ",Str "a",Str " ",Str "variation",Str " ",Str "on",Str " ",Str "the",Str " ",Str "previous",Str " ",Str "example,",Str " ",Str "showing",Str " ",Str "that",Str " ",Str "no",Str " ",Str "further",Str " ",Str "elements",Str " ",Str "are",Str " ",Str "taken",Str " ",Str "from",Str " ",Code ("",[],[]) "iter",Str " ",Str "after",Str " ",Str "the",Str " ",Str "first",Str " ",Code ("",[],[]) "None",Str "."]
    ,Div ("",["example-wrap"],[])
     [Para [Str "#+BEGIN_SRC rust \n",Str "let items = vec![3_u16, 2, 1, 10];\n\nlet mut shared = 0;\n\nlet res: Option<Vec<u16>> = items\n    .iter()\n    .map(|x| { shared += x; x.checked_sub(2) })\n    .collect();\n\nassert_eq!(res, None);\nassert_eq!(shared, 6);",Str "\n#+END_SRC"]
     ,Null]
    ,Para [Str "Since",Str " ",Str "the",Str " ",Str "third",Str " ",Str "element",Str " ",Str "caused",Str " ",Str "an",Str " ",Str "underflow,",Str " ",Str "no",Str " ",Str "further",Str " ",Str "elements",Str " ",Str "were",Str " ",Str "taken,",Str " ",Str "so",Str " ",Str "the",Str " ",Str "final",Str " ",Str "value",Str " ",Str "of",Str " ",Code ("",[],[]) "shared",Str " ",Str "is",Str " ",Str "6",Str " ",Str "(=",Str " ",Code ("",[],[]) "3 + 2 + 1",Str "),",Str " ",Str "not",Str " ",Str "16."]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Hash for Option<T> where\160\160\160\160T: Hash,\160"]
  ,Div ("",["impl-items"],[])
   [Header 3 ("",[],[]) [Code ("hash.v",[],[]) "fn hash<__H>(&self, state: &mut __H) where\160\160\160\160__H: Hasher,\160"]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "Feeds",Str " ",Str "this",Str " ",Str "value",Str " ",Str "into",Str " ",Str "the",Str " ",Str "given",Str " ",Str "[",Code ("",[],[]) "Hasher",Str "].",Str " ",Span ("",[],[]) [Str "Read",Str " ",Str "more"]]]
   ,Header 3 ("",[],[]) [Code ("hash_slice.v",[],[]) "fn hash_slice<H>(data: &[Self], state: &mut H) where\160\160\160\160H: Hasher,\160"]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "Feeds",Str " ",Str "a",Str " ",Str "slice",Str " ",Str "of",Str " ",Str "this",Str " ",Str "type",Str " ",Str "into",Str " ",Str "the",Str " ",Str "given",Str " ",Str "[",Code ("",[],[]) "Hasher",Str "].",Str " ",Span ("",[],[]) [Str "Read",Str " ",Str "more"]]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> IntoIterator for Option<T>"]
  ,Div ("",["impl-items"],[])
   [Null
   ,Div ("",[],[])
    [Para [Str "The",Str " ",Str "type",Str " ",Str "of",Str " ",Str "the",Str " ",Str "elements",Str " ",Str "being",Str " ",Str "iterated",Str " ",Str "over."]]
   ,Null
   ,Div ("",[],[])
    [Para [Str "Which",Str " ",Str "kind",Str " ",Str "of",Str " ",Str "iterator",Str " ",Str "are",Str " ",Str "we",Str " ",Str "turning",Str " ",Str "this",Str " ",Str "into?"]]
   ,Header 3 ("",[],[]) [Code ("into_iter.v",[],[]) "fn into_iter(self) -> IntoIter<T>"]
   ,Div ("",[],[])
    [Para [Str "Returns",Str " ",Str "a",Str " ",Str "consuming",Str " ",Str "iterator",Str " ",Str "over",Str " ",Str "the",Str " ",Str "possibly",Str " ",Str "contained",Str " ",Str "value."]
    ,Null
    ,Div ("",["example-wrap"],[])
     [Para [Str "#+BEGIN_SRC rust \n",Str "let x = Some(\"string\");\nlet v: Vec<&str> = x.into_iter().collect();\nassert_eq!(v, [\"string\"]);\n\nlet x = None;\nlet v: Vec<&str> = x.into_iter().collect();\nassert!(v.is_empty());",Str "\n#+END_SRC"]
     ,Null]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<'a, T> IntoIterator for &'a Option<T>"]
  ,Div ("",["impl-items"],[])
   [Null
   ,Div ("",[],[])
    [Para [Str "The",Str " ",Str "type",Str " ",Str "of",Str " ",Str "the",Str " ",Str "elements",Str " ",Str "being",Str " ",Str "iterated",Str " ",Str "over."]]
   ,Null
   ,Div ("",[],[])
    [Para [Str "Which",Str " ",Str "kind",Str " ",Str "of",Str " ",Str "iterator",Str " ",Str "are",Str " ",Str "we",Str " ",Str "turning",Str " ",Str "this",Str " ",Str "into?"]]
   ,Header 3 ("",[],[]) [Code ("into_iter.v-1",[],[]) "fn into_iter(self) -> Iter<'a, T>"]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "Creates",Str " ",Str "an",Str " ",Str "iterator",Str " ",Str "from",Str " ",Str "a",Str " ",Str "value.",Str " ",Span ("",[],[]) [Str "Read",Str " ",Str "more"]]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<'a, T> IntoIterator for &'a mut Option<T>"]
  ,Div ("",["impl-items"],[])
   [Null
   ,Div ("",[],[])
    [Para [Str "The",Str " ",Str "type",Str " ",Str "of",Str " ",Str "the",Str " ",Str "elements",Str " ",Str "being",Str " ",Str "iterated",Str " ",Str "over."]]
   ,Null
   ,Div ("",[],[])
    [Para [Str "Which",Str " ",Str "kind",Str " ",Str "of",Str " ",Str "iterator",Str " ",Str "are",Str " ",Str "we",Str " ",Str "turning",Str " ",Str "this",Str " ",Str "into?"]]
   ,Header 3 ("",[],[]) [Code ("into_iter.v-2",[],[]) "fn into_iter(self) -> IterMut<'a, T>"]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "Creates",Str " ",Str "an",Str " ",Str "iterator",Str " ",Str "from",Str " ",Str "a",Str " ",Str "value.",Str " ",Span ("",[],[]) [Str "Read",Str " ",Str "more"]]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Ord for Option<T> where\160\160\160\160T: Ord,\160"]
  ,Div ("",["impl-items"],[])
   [Header 3 ("",[],[]) [Code ("cmp.v",[],[]) "fn cmp(&self, other: &Option<T>) -> Ordering"]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "This",Str " ",Str "method",Str " ",Str "returns",Str " ",Str "an",Str " ",Str "[",Code ("",[],[]) "Ordering",Str "]",Str " ",Str "between",Str " ",Code ("",[],[]) "self",Str " ",Str "and",Str " ",Code ("",[],[]) "other",Str ".",Str " ",Span ("",[],[]) [Str "Read",Str " ",Str "more"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "fn max(self, other: Self) -> Self",Str " "]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "Compares",Str " ",Str "and",Str " ",Str "returns",Str " ",Str "the",Str " ",Str "maximum",Str " ",Str "of",Str " ",Str "two",Str " ",Str "values.",Str " ",Span ("",[],[]) [Str "Read",Str " ",Str "more"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "fn min(self, other: Self) -> Self",Str " "]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "Compares",Str " ",Str "and",Str " ",Str "returns",Str " ",Str "the",Str " ",Str "minimum",Str " ",Str "of",Str " ",Str "two",Str " ",Str "values.",Str " ",Span ("",[],[]) [Str "Read",Str " ",Str "more"]]]
   ,Header 3 ("",[],[]) [Code ("",[],[]) "fn clamp(self, min: Self, max: Self) -> Self",Str " "]
   ,Plain [Str "This",Str " ",Str "is",Str " ",Str "a",Str " ",Str "nightly-only",Str " ",Str "experimental",Str " ",Str "API.",Str " ",Str "(",Code ("",[],[]) "clamp",Str "\160",Span ("",[],[]) [Str "#44095"],Str ")",Str " "]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "Restrict",Str " ",Str "a",Str " ",Str "value",Str " ",Str "to",Str " ",Str "a",Str " ",Str "certain",Str " ",Str "interval.",Str " ",Span ("",[],[]) [Str "Read",Str " ",Str "more"]]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> PartialEq<Option<T>> for Option<T> where\160\160\160\160T: PartialEq<T>,\160"]
  ,Div ("",["impl-items"],[])
   [Header 3 ("",[],[]) [Code ("eq.v",[],[]) "fn eq(&self, other: &Option<T>) -> bool"]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "This",Str " ",Str "method",Str " ",Str "tests",Str " ",Str "for",Str " ",Code ("",[],[]) "self",Str " ",Str "and",Str " ",Code ("",[],[]) "other",Str " ",Str "values",Str " ",Str "to",Str " ",Str "be",Str " ",Str "equal,",Str " ",Str "and",Str " ",Str "is",Str " ",Str "used",Str " ",Str "by",Str " ",Code ("",[],[]) "==",Str ".",Str " ",Span ("",[],[]) [Str "Read",Str " ",Str "more"]]]
   ,Header 3 ("",[],[]) [Code ("ne.v",[],[]) "fn ne(&self, other: &Option<T>) -> bool"]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "This",Str " ",Str "method",Str " ",Str "tests",Str " ",Str "for",Str " ",Code ("",[],[]) "!=",Str "."]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> PartialOrd<Option<T>> for Option<T> where\160\160\160\160T: PartialOrd<T>,\160"]
  ,Div ("",["impl-items"],[])
   [Header 3 ("",[],[]) [Code ("partial_cmp.v",[],[]) "fn partial_cmp(&self, other: &Option<T>) -> Option<Ordering>"]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "This",Str " ",Str "method",Str " ",Str "returns",Str " ",Str "an",Str " ",Str "ordering",Str " ",Str "between",Str " ",Code ("",[],[]) "self",Str " ",Str "and",Str " ",Code ("",[],[]) "other",Str " ",Str "values",Str " ",Str "if",Str " ",Str "one",Str " ",Str "exists.",Str " ",Span ("",[],[]) [Str "Read",Str " ",Str "more"]]]
   ,Header 3 ("",[],[]) [Code ("lt.v",[],[]) "fn lt(&self, other: &Option<T>) -> bool"]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "This",Str " ",Str "method",Str " ",Str "tests",Str " ",Str "less",Str " ",Str "than",Str " ",Str "(for",Str " ",Code ("",[],[]) "self",Str " ",Str "and",Str " ",Code ("",[],[]) "other",Str ")",Str " ",Str "and",Str " ",Str "is",Str " ",Str "used",Str " ",Str "by",Str " ",Str "the",Str " ",Code ("",[],[]) "<",Str " ",Str "operator.",Str " ",Span ("",[],[]) [Str "Read",Str " ",Str "more"]]]
   ,Header 3 ("",[],[]) [Code ("le.v",[],[]) "fn le(&self, other: &Option<T>) -> bool"]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "This",Str " ",Str "method",Str " ",Str "tests",Str " ",Str "less",Str " ",Str "than",Str " ",Str "or",Str " ",Str "equal",Str " ",Str "to",Str " ",Str "(for",Str " ",Code ("",[],[]) "self",Str " ",Str "and",Str " ",Code ("",[],[]) "other",Str ")",Str " ",Str "and",Str " ",Str "is",Str " ",Str "used",Str " ",Str "by",Str " ",Str "the",Str " ",Code ("",[],[]) "<=",Str " ",Str "operator.",Str " ",Span ("",[],[]) [Str "Read",Str " ",Str "more"]]]
   ,Header 3 ("",[],[]) [Code ("gt.v",[],[]) "fn gt(&self, other: &Option<T>) -> bool"]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "This",Str " ",Str "method",Str " ",Str "tests",Str " ",Str "greater",Str " ",Str "than",Str " ",Str "(for",Str " ",Code ("",[],[]) "self",Str " ",Str "and",Str " ",Code ("",[],[]) "other",Str ")",Str " ",Str "and",Str " ",Str "is",Str " ",Str "used",Str " ",Str "by",Str " ",Str "the",Str " ",Code ("",[],[]) ">",Str " ",Str "operator.",Str " ",Span ("",[],[]) [Str "Read",Str " ",Str "more"]]]
   ,Header 3 ("",[],[]) [Code ("ge.v",[],[]) "fn ge(&self, other: &Option<T>) -> bool"]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "This",Str " ",Str "method",Str " ",Str "tests",Str " ",Str "greater",Str " ",Str "than",Str " ",Str "or",Str " ",Str "equal",Str " ",Str "to",Str " ",Str "(for",Str " ",Code ("",[],[]) "self",Str " ",Str "and",Str " ",Code ("",[],[]) "other",Str ")",Str " ",Str "and",Str " ",Str "is",Str " ",Str "used",Str " ",Str "by",Str " ",Str "the",Str " ",Code ("",[],[]) ">=",Str " ",Str "operator.",Str " ",Span ("",[],[]) [Str "Read",Str " ",Str "more"]]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T, U> Product<Option<U>> for Option<T> where\160\160\160\160T: Product<U>,\160"]
  ,Div ("",["impl-items"],[])
   [Header 3 ("",[],[]) [Code ("product.v",[],[]) "fn product<I>(iter: I) -> Option<T> where\160\160\160\160I: Iterator<Item = Option<U>>,\160"]
   ,Div ("",[],[])
    [Para [Str "Takes",Str " ",Str "each",Str " ",Str "element",Str " ",Str "in",Str " ",Str "the",Str " ",Code ("",[],[]) "Iterator",Str ":",Str " ",Str "if",Str " ",Str "it",Str " ",Str "is",Str " ",Str "a",Str " ",Code ("",[],[]) "None",Str ",",Str " ",Str "no",Str " ",Str "further",Str " ",Str "elements",Str " ",Str "are",Str " ",Str "taken,",Str " ",Str "and",Str " ",Str "the",Str " ",Code ("",[],[]) "None",Str " ",Str "is",Str " ",Str "returned.",Str " ",Str "Should",Str " ",Str "no",Str " ",Code ("",[],[]) "None",Str " ",Str "occur,",Str " ",Str "the",Str " ",Str "product",Str " ",Str "of",Str " ",Str "all",Str " ",Str "elements",Str " ",Str "is",Str " ",Str "returned."]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> StructuralEq for Option<T>"]
  ,Div ("",["impl-items"],[])
   []
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> StructuralPartialEq for Option<T>"]
  ,Div ("",["impl-items"],[])
   []
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T, U> Sum<Option<U>> for Option<T> where\160\160\160\160T: Sum<U>,\160"]
  ,Div ("",["impl-items"],[])
   [Header 3 ("",[],[]) [Code ("sum.v",[],[]) "fn sum<I>(iter: I) -> Option<T> where\160\160\160\160I: Iterator<Item = Option<U>>,\160"]
   ,Div ("",[],[])
    [Para [Str "Takes",Str " ",Str "each",Str " ",Str "element",Str " ",Str "in",Str " ",Str "the",Str " ",Code ("",[],[]) "Iterator",Str ":",Str " ",Str "if",Str " ",Str "it",Str " ",Str "is",Str " ",Str "a",Str " ",Code ("",[],[]) "None",Str ",",Str " ",Str "no",Str " ",Str "further",Str " ",Str "elements",Str " ",Str "are",Str " ",Str "taken,",Str " ",Str "and",Str " ",Str "the",Str " ",Code ("",[],[]) "None",Str " ",Str "is",Str " ",Str "returned.",Str " ",Str "Should",Str " ",Str "no",Str " ",Code ("",[],[]) "None",Str " ",Str "occur,",Str " ",Str "the",Str " ",Str "sum",Str " ",Str "of",Str " ",Str "all",Str " ",Str "elements",Str " ",Str "is",Str " ",Str "returned."]
    ,Null
    ,Para [Str "This",Str " ",Str "sums",Str " ",Str "up",Str " ",Str "the",Str " ",Str "position",Str " ",Str "of",Str " ",Str "the",Str " ",Str "character",Str " ",Str "'a'",Str " ",Str "in",Str " ",Str "a",Str " ",Str "vector",Str " ",Str "of",Str " ",Str "strings,",Str " ",Str "if",Str " ",Str "a",Str " ",Str "word",Str " ",Str "did",Str " ",Str "not",Str " ",Str "have",Str " ",Str "the",Str " ",Str "character",Str " ",Str "'a'",Str " ",Str "the",Str " ",Str "operation",Str " ",Str "returns",Str " ",Code ("",[],[]) "None",Str ":"]
    ,Div ("",["example-wrap"],[])
     [Para [Str "#+BEGIN_SRC rust \n",Str "let words = vec![\"have\", \"a\", \"great\", \"day\"];\nlet total: Option<usize> = words.iter().map(|w| w.find('a')).sum();\nassert_eq!(total, Some(5));",Str "\n#+END_SRC"]
     ,Null]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Try for Option<T>"]
  ,Div ("",["impl-items"],[])
   [Null
   ,Plain [Str "This",Str " ",Str "is",Str " ",Str "a",Str " ",Str "nightly-only",Str " ",Str "experimental",Str " ",Str "API.",Str " ",Str "(",Code ("",[],[]) "try_trait",Str "\160",Span ("",[],[]) [Str "#42327"],Str ")",Str " "]
   ,Div ("",[],[])
    [Para [Str "The",Str " ",Str "type",Str " ",Str "of",Str " ",Str "this",Str " ",Str "value",Str " ",Str "when",Str " ",Str "viewed",Str " ",Str "as",Str " ",Str "successful."]]
   ,Null
   ,Plain [Str "This",Str " ",Str "is",Str " ",Str "a",Str " ",Str "nightly-only",Str " ",Str "experimental",Str " ",Str "API.",Str " ",Str "(",Code ("",[],[]) "try_trait",Str "\160",Span ("",[],[]) [Str "#42327"],Str ")",Str " "]
   ,Div ("",[],[])
    [Para [Str "The",Str " ",Str "type",Str " ",Str "of",Str " ",Str "this",Str " ",Str "value",Str " ",Str "when",Str " ",Str "viewed",Str " ",Str "as",Str " ",Str "failed."]]
   ,Header 3 ("",[],[]) [Code ("into_result.v",[],[]) "fn into_result(self) -> Result<T, NoneError>"]
   ,Plain [Str "This",Str " ",Str "is",Str " ",Str "a",Str " ",Str "nightly-only",Str " ",Str "experimental",Str " ",Str "API.",Str " ",Str "(",Code ("",[],[]) "try_trait",Str "\160",Span ("",[],[]) [Str "#42327"],Str ")",Str " "]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "Applies",Str " ",Str "the",Str " ",Str "\"?\"",Str " ",Str "operator.",Str " ",Str "A",Str " ",Str "return",Str " ",Str "of",Str " ",Code ("",[],[]) "Ok(t)",Str " ",Str "means",Str " ",Str "that",Str " ",Str "the",Str " ",Str "execution",Str " ",Str "should",Str " ",Str "continue",Str " ",Str "normally,",Str " ",Str "and",Str " ",Str "the",Str " ",Str "result",Str " ",Str "of",Str " ",Code ("",[],[]) "?",Str " ",Str "is",Str " ",Str "the",Str " ",Str "value",Str " ",Code ("",[],[]) "t",Str ".",Str " ",Str "A",Str " ",Str "return",Str " ",Str "of",Str " ",Code ("",[],[]) "Err(e)",Str " ",Str "means",Str " ",Str "that",Str " ",Str "execution",Str " ",Str "should",Str " ",Str "branch",Str " ",Str "to",Str " ",Str "the",Str " ",Str "innermost",Str " ",Str "enclosing",Str " ",Code ("",[],[]) "catch",Str ",",Str " ",Str "or",Str " ",Str "return",Str " ",Str "from",Str " ",Str "the",Str " ",Str "function.",Str " ",Span ("",[],[]) [Str "Read",Str " ",Str "more"]]]
   ,Header 3 ("",[],[]) [Code ("from_ok.v",[],[]) "fn from_ok(v: T) -> Option<T>"]
   ,Plain [Str "This",Str " ",Str "is",Str " ",Str "a",Str " ",Str "nightly-only",Str " ",Str "experimental",Str " ",Str "API.",Str " ",Str "(",Code ("",[],[]) "try_trait",Str "\160",Span ("",[],[]) [Str "#42327"],Str ")",Str " "]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "Wrap",Str " ",Str "an",Str " ",Str "OK",Str " ",Str "value",Str " ",Str "to",Str " ",Str "construct",Str " ",Str "the",Str " ",Str "composite",Str " ",Str "result.",Str " ",Str "For",Str " ",Str "example,",Str " ",Code ("",[],[]) "Result::Ok(x)",Str " ",Str "and",Str " ",Code ("",[],[]) "Result::from_ok(x)",Str " ",Str "are",Str " ",Str "equivalent.",Str " ",Span ("",[],[]) [Str "Read",Str " ",Str "more"]]]
   ,Header 3 ("",[],[]) [Code ("from_error.v",[],[]) "fn from_error(NoneError) -> Option<T>"]
   ,Plain [Str "This",Str " ",Str "is",Str " ",Str "a",Str " ",Str "nightly-only",Str " ",Str "experimental",Str " ",Str "API.",Str " ",Str "(",Code ("",[],[]) "try_trait",Str "\160",Span ("",[],[]) [Str "#42327"],Str ")",Str " "]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "Wrap",Str " ",Str "an",Str " ",Str "error",Str " ",Str "value",Str " ",Str "to",Str " ",Str "construct",Str " ",Str "the",Str " ",Str "composite",Str " ",Str "result.",Str " ",Str "For",Str " ",Str "example,",Str " ",Code ("",[],[]) "Result::Err(x)",Str " ",Str "and",Str " ",Code ("",[],[]) "Result::from_error(x)",Str " ",Str "are",Str " ",Str "equivalent.",Str " ",Span ("",[],[]) [Str "Read",Str " ",Str "more"]]]]]
 ,Header 1 ("",[],[]) [Str "Auto",Str " ",Str "Trait",Str " ",Str "Implementations"]
 ,Div ("",[],[])
  [Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> RefUnwindSafe for Option<T> where\160\160\160\160T: RefUnwindSafe,\160"]
  ,Div ("",["impl-items"],[])
   []
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Send for Option<T> where\160\160\160\160T: Send,\160"]
  ,Div ("",["impl-items"],[])
   []
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Sync for Option<T> where\160\160\160\160T: Sync,\160"]
  ,Div ("",["impl-items"],[])
   []
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Unpin for Option<T> where\160\160\160\160T: Unpin,\160"]
  ,Div ("",["impl-items"],[])
   []
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> UnwindSafe for Option<T> where\160\160\160\160T: UnwindSafe,\160"]
  ,Div ("",["impl-items"],[])
   []]
 ,Header 1 ("",[],[]) [Str "Blanket",Str " ",Str "Implementations"]
 ,Div ("",[],[])
  [Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Any for T where\160\160\160\160T: 'static + ?Sized,\160"]
  ,Div ("",["impl-items"],[])
   [Header 3 ("",[],[]) [Code ("type_id.v",[],[]) "fn type_id(&self) -> TypeId"]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "Gets",Str " ",Str "the",Str " ",Code ("",[],[]) "TypeId",Str " ",Str "of",Str " ",Code ("",[],[]) "self",Str ".",Str " ",Span ("",[],[]) [Str "Read",Str " ",Str "more"]]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> Borrow<T> for T where\160\160\160\160T: ?Sized,\160"]
  ,Div ("",["impl-items"],[])
   [Header 3 ("",[],[]) [Code ("borrow.v",[],[]) "fn borrow(&self) -> &T"]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "Immutably",Str " ",Str "borrows",Str " ",Str "from",Str " ",Str "an",Str " ",Str "owned",Str " ",Str "value.",Str " ",Span ("",[],[]) [Str "Read",Str " ",Str "more"]]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> BorrowMut<T> for T where\160\160\160\160T: ?Sized,\160"]
  ,Div ("",["impl-items"],[])
   [Header 3 ("",[],[]) [Code ("borrow_mut.v",[],[]) "fn borrow_mut(&mut self) -> &mut T"]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "Mutably",Str " ",Str "borrows",Str " ",Str "from",Str " ",Str "an",Str " ",Str "owned",Str " ",Str "value.",Str " ",Span ("",[],[]) [Str "Read",Str " ",Str "more"]]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> From<!> for T"]
  ,Div ("",["impl-items"],[])
   [Header 3 ("",[],[]) [Code ("from.v-4",[],[]) "fn from(t: !) -> T"]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "Performs",Str " ",Str "the",Str " ",Str "conversion."]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> From<T> for T"]
  ,Div ("",["impl-items"],[])
   [Header 3 ("",[],[]) [Code ("from.v-3",[],[]) "fn from(t: T) -> T"]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "Performs",Str " ",Str "the",Str " ",Str "conversion."]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T, U> Into<U> for T where\160\160\160\160U: From<T>,\160"]
  ,Div ("",["impl-items"],[])
   [Header 3 ("",[],[]) [Code ("into.v",[],[]) "fn into(self) -> U"]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "Performs",Str " ",Str "the",Str " ",Str "conversion."]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<I> IntoIterator for I where\160\160\160\160I: Iterator,\160"]
  ,Div ("",["impl-items"],[])
   [Null
   ,Div ("",[],[])
    [Para [Str "The",Str " ",Str "type",Str " ",Str "of",Str " ",Str "the",Str " ",Str "elements",Str " ",Str "being",Str " ",Str "iterated",Str " ",Str "over."]]
   ,Null
   ,Div ("",[],[])
    [Para [Str "Which",Str " ",Str "kind",Str " ",Str "of",Str " ",Str "iterator",Str " ",Str "are",Str " ",Str "we",Str " ",Str "turning",Str " ",Str "this",Str " ",Str "into?"]]
   ,Header 3 ("",[],[]) [Code ("into_iter.v-3",[],[]) "fn into_iter(self) -> I"]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "Creates",Str " ",Str "an",Str " ",Str "iterator",Str " ",Str "from",Str " ",Str "a",Str " ",Str "value.",Str " ",Span ("",[],[]) [Str "Read",Str " ",Str "more"]]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T> ToOwned for T where\160\160\160\160T: Clone,\160"]
  ,Div ("",["impl-items"],[])
   [Null
   ,Div ("",[],[])
    [Para [Str "The",Str " ",Str "resulting",Str " ",Str "type",Str " ",Str "after",Str " ",Str "obtaining",Str " ",Str "ownership."]]
   ,Header 3 ("",[],[]) [Code ("to_owned.v",[],[]) "fn to_owned(&self) -> T"]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "Creates",Str " ",Str "owned",Str " ",Str "data",Str " ",Str "from",Str " ",Str "borrowed",Str " ",Str "data,",Str " ",Str "usually",Str " ",Str "by",Str " ",Str "cloning.",Str " ",Span ("",[],[]) [Str "Read",Str " ",Str "more"]]]
   ,Header 3 ("",[],[]) [Code ("clone_into.v",[],[]) "fn clone_into(&self, target: &mut T)"]
   ,Plain [Str "This",Str " ",Str "is",Str " ",Str "a",Str " ",Str "nightly-only",Str " ",Str "experimental",Str " ",Str "API.",Str " ",Str "(",Code ("",[],[]) "toowned_clone_into",Str "\160",Span ("",[],[]) [Str "#41263"],Str ")",Str " ",Str "recently",Str " ",Str "added"]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "Uses",Str " ",Str "borrowed",Str " ",Str "data",Str " ",Str "to",Str " ",Str "replace",Str " ",Str "owned",Str " ",Str "data,",Str " ",Str "usually",Str " ",Str "by",Str " ",Str "cloning.",Str " ",Span ("",[],[]) [Str "Read",Str " ",Str "more"]]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T, U> TryFrom<U> for T where\160\160\160\160U: Into<T>,\160"]
  ,Div ("",["impl-items"],[])
   [Null
   ,Div ("",[],[])
    [Para [Str "The",Str " ",Str "type",Str " ",Str "returned",Str " ",Str "in",Str " ",Str "the",Str " ",Str "event",Str " ",Str "of",Str " ",Str "a",Str " ",Str "conversion",Str " ",Str "error."]]
   ,Header 3 ("",[],[]) [Code ("try_from.v",[],[]) "fn try_from(value: U) -> Result<T, <T as TryFrom<U>>::Error>"]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "Performs",Str " ",Str "the",Str " ",Str "conversion."]]]
  ,Header 2 ("",[],[]) [Code ("",["in-band"],[]) "impl<T, U> TryInto<U> for T where\160\160\160\160U: TryFrom<T>,\160"]
  ,Div ("",["impl-items"],[])
   [Null
   ,Div ("",[],[])
    [Para [Str "The",Str " ",Str "type",Str " ",Str "returned",Str " ",Str "in",Str " ",Str "the",Str " ",Str "event",Str " ",Str "of",Str " ",Str "a",Str " ",Str "conversion",Str " ",Str "error."]]
   ,Header 3 ("",[],[]) [Code ("try_into.v",[],[]) "fn try_into(self) -> Result<U, <U as TryFrom<T>>::Error>"]
   ,Div ("",["docblock","hidden"],[])
    [Para [Str "Performs",Str " ",Str "the",Str " ",Str "conversion."]]]]]
,Div ("",[],[])
 []
,Div ("",["section","footer"],[])
 []]
